STARTER PROMPT (PL)

Buduj aplikację React + Vite (frontend-only), która generuje plik Word (.docx) zawierający karty z QR kodami. Aplikacja NIE łączy się z backendem — wszystko działa w przeglądarce. Implementacja ma być produkcyjna (obsługa błędów wejściowych, walidacja CSV, możliwość pobrania pliku).

Główne wymagania funkcjonalne

Użytkownik ładuje plik CSV przez przeglądarkę (przeciągnij & upuść lub input file). Parsowanie CSV po stronie klienta (np. papaparse). Plik CSV może być rozdzielany tabulatorami lub przecinkami — obsłużyć oba przypadki.

Dla każdej poprawnej linii CSV wygenerować unikalny QR code prowadzący do URL zawartego w wierszu CSV (URL jest polem CSV, patrz mapowanie niżej). QR generowany w pamięci jako data:image/png;base64,... (np. biblioteka qrcode lub qrcode.react).

Wygenerować dokument A4 (.docx) z układem 3 kolumn kart na stronę. Między kartami ma być 3 mm odstępu (horyzontalnie i wertykalnie).

Każda karta ma zawierać:

estetyczny padding wewnątrz karty,

QR code po lewej stronie (rozsądny rozmiar, np. 24–30 mm szerokości),

po prawej stronie: nazwa produktu (pogrubiona) oraz pod nią mniejszym tekstem: "zaskanuj aby zobaczyć szczegóły i cenę",

teksty powinny być wyrównane pionowo do środka wysokości karty.

Generacja i złożenie dokumentu .docx ma być wykonywana w przeglądarce (np. biblioteka docx dla JS), a użytkownik otrzymuje przycisk do pobrania pliku (qrcards.docx).

Aplikacja powinna obsłużyć paginację dokumentu — jeśli więcej kart niż mieści się na stronie, generujemy kolejne strony A4 z tym samym układem.

Mapowanie CSV (konkretne)

Zakładamy, że przykładowy wiersz CSV (pól rozdzielonych tabulatorami) wygląda tak:

recH0IoWaAy9p16Ld	0110_SM_2800x2070_18	0110	SM	BIAŁY KORPUSOWY	https://azmproducts.plasmic.run/product/recH0IoWaAy9p16Ld	PLN 215,84	...


Nazwa produktu = pole numer 2 (0-based index = 1): 0110_SM_2800x2070_18

URL dla QR = pole numer 6 (0-based index = 5): https://azmproducts...

Pozostałe pola IGNORUJEMY do działania, ale zachowujemy możliwość rozszerzenia w przyszłości.

Dokładne wymiary i wyliczenia (konkret, krok po kroku)

Używamy jednostek milimetrów (mm) i zaokrągleń tak, aby wynik był precyzyjny:

Rozmiar strony A4: 210 mm × 297 mm.

Ustalamy marginesy strony: 12 mm z lewej i prawej, oraz 12 mm z góry i dołu.

Obliczenie szerokości obszaru zapełnienia (content width):

210 mm (szerokość A4) − 12 mm (lewy margines) − 12 mm (prawy margines)
=> 210 − 12 − 12 = 186 mm (to szerokość dostępna na kolumny).

Odstęp między kolumnami (między kartami): 3 mm. Dla trzech kolumn występują 2 odstępy poziome: 2 × 3 mm = 6 mm.

Szerokość każdej karty = (dostępna szerokość − suma odstępów) ÷ 3:

(186 − 6) ÷ 3 = 180 ÷ 3 = 60 mm szerokości karty.

Wysokość obszaru zapełnienia (content height):

297 mm (wys. A4) − 12 mm (góra) − 12 mm (dół) = 273 mm.

Ustalamy wysokość karty (przykładowo): 50 mm (dobry kompromis dla QR + tekstu).

Odstęp pionowy między kartami: 3 mm.

Obliczenie liczby rzędów mieszczących się na stronie:

Używamy wzoru: rows = floor( (content_height + gap) / (card_height + gap) )

Podstawiamy cyfry: (273 + 3) ÷ (50 + 3) = 276 ÷ 53

53 × 5 = 265, 53 × 6 = 318 > 276 → więc mieści się 5 rzędów.

W efekcie: 3 kolumny × 5 rzędów = 15 kart na stronę.

Uwaga implementacyjna: biblioteka docx może wymagać jednostek w punktach/twipach; przekaż konwersję w kodzie (mm → twip: twip = mm / 25.4 * 1440). Podaj te przeliczenia w implementacji.

Biblioteki / narzędzia sugerowane do użycia (frontend only)

react + vite (szablon)

papaparse — parsing CSV po stronie klienta (obsługa separatorów, nagłówków)

qrcode (np. qrcode npm) — generowanie danych obrazów QR (toDataURL)

docx (npm) — tworzenie pliku .docx w przeglądarce i osadzanie obrazów

file-saver — zapisywanie pliku z frontendu

uuid — (opcjonalnie) tworzenie unikalnych identyfikatorów / nazw plików

UI / UX (co musi zawierać aplikacja)

Pole do uploadu CSV (drag & drop + wybór pliku).

Podgląd pierwszych N wierszy CSV (np. 10) z wyszczególnieniem nazwy i URL, możliwość wykluczenia wierszy.

Opcje ustawień: rozmiar QR (mm), rozmiar karty (mm) — domyślnie QR = 28 mm, karta = 50 mm.

Przycisk "Generuj .docx" — po kliknięciu: wygeneruj i pobierz dokument.

Informacje o błędach (np. brak URL, nieprawidłowy URL, zduplikowane rekordy).

Wytyczne implementacyjne (ważne detale techniczne)

QR generuj jako data:image/png;base64,... i wstawiaj do dokumentu jako obraz binarny (biblioteka docx pozwala wstawiać obrazy z base64).

Każda karta to w docx komórka tabeli lub kontener z ustalonym wymiarem (szer. 60 mm, wys. 50 mm) i paddingiem wewnętrznym np. 4–6 mm.

Layout karty: użyj dwóch kolumn wewnątrz karty:

lewa kolumna: obraz QR o szerokości np. 28 mm (wysokość skalowana proporcjonalnie),

prawa kolumna: blok tekstu z nazwą produktu (pogrubiony, większa czcionka) i poniżej mniejszy tekst: "zaskanuj aby zobaczyć szczegóły i cenę".

Wyrównaj treść pionowo do środka oraz dodaj odstęp między QR i tekstem (np. 6–8 mm).

Upewnij się, że obrazy QR mają odpowiednią rozdzielczość — generuj je w wielkości pikselowej odpowiadającej mm przeliczonym na DPI (np. dla bezpieczeństwa 300 DPI) — ale nie ekstremalnie duże, by nie zablokować pamięci.

Obsłuż paginację: jeśli liczba kart > 15, dodaj kolejne strony A4 z tym samym układem.

Testy akceptacyjne (konkretne)

Dla pliku CSV zawierającego 15 poprawnych wierszy aplikacja generuje 1 plik .docx z dokładnie 15 kart na pierwszej stronie (3 kolumny × 5 rzędów) i nie dodaje pustych kart.

Dla pliku CSV z 20 wierszami — generuje dokument z 2 stronami: pierwsza 15 kart, druga 5 kart.

Dla każdego wiersza: w karcie pojawia się nazwa produktu dokładnie z pola CSV (index 1) oraz po lewej QR prowadzący do URL z pola CSV (index 5). Kliknięcie QR w rzeczywistym Wordzie powinno otwierać URL (test funkcjonalnie: skanując QR w pliku Word/po wydruku).

Między kolumnami i rzędami jest widoczny odstęp 3 mm. (Można to sprawdzić poprzez wymiary karty i marginesy w wygenerowanym dokumencie).

Aplikacja działa całkowicie offline w przeglądarce — nie wykonuje żadnych zapytań sieciowych do generowania QR / tworzenia docx.

Edge cases i dodatkowe wymagania

Walidacja URL: ignoruj/oznacz wiersze bez prawidłowego URL ( brak http:// / https:// ) i powiadom użytkownika.

Obsłuż duplikaty (możliwość zignorowania lub oznaczenia).

Obsłuż różne separatory CSV: , i \t (tab).

Zadbaj o pamięć: jeśli plik CSV jest bardzo duży (>1000 wierszy), pokaż ostrzeżenie wydajnościowe i zaproponuj rozbicie pliku.

Rezultat oczekiwany od asystenta kodowania

Kompletny projekt React + Vite (komendy npm create vite... + gotowe pliki src/).

Implementacja komponentów: UploadCSV, PreviewTable, SettingsPanel, GenerateDocButton.

Funkcjonalne generowanie QR + osadzenie w .docx + pobieranie pliku.

Krótkie instrukcje uruchomienia (install, run).

Prosty CSS/Tailwind dla estetyki (opcjonalnie).

Dodatkowe uwagi

Jeśli natrafisz na ograniczenie biblioteki docx przy precyzyjnym rozmieszczaniu elementów, alternatywnie możesz generować PDF (np. przy pomocy pdf-lib lub generując HTML i renderując do PDF) — ale domyślnie implementuj .docx tak jak powyżej.

Zadbaj o czystą strukturę kodu i testowalność: rozdziel logikę parsowania CSV, generowania QR i składania dokumentu.